[{"name":"Form","comment":"\n\n\n## Example\n\nLet's look at a sign-up form example.\n\nWhat to look for:\n\n**The field declarations**\n\nBelow the `Form.form` call you will find all of the form's fields declared with\n\n    |> Form.field ...\n\nThese are the form's field declarations.\n\nThese fields each have individual validations. For example, `|> Field.required ...` means we'll get a validation\nerror if that field is empty (similar for checking the minimum password length). This field definition defines\nsome information that will be used when render the field using [`Form.FieldView`](Form-FieldView) (whether it is a date input, password input, etc.).\n\nThere will be a corresponding parameter in the function we pass in to `Form.form` for every\nfield declaration (in this example, `\\email password passwordConfirmation -> ...`).\n\n**The `combine` validation**\n\nIn addition to the validation errors that individual fields can have independently (like\nrequired fields or minimum password length), we can also do _dependent validations_.\n\nWe use the [`Form.Validation`](Form-Validation) module to take each individual field and combine\nthem into a type and/or errors.\n\n**The `view`**\n\nIn your view you can lay out your fields however you want. While you will be using [`Form.FieldView`](Form-FieldView)\nto render the fields themselves, the rendering for everything besides the fields (including `label`'s, `div`s, etc.) is completely up to you.\n\n    import Form\n    import Form.Field as Field\n    import Form.FieldView as FieldView\n    import Form.Validation as Validation\n    import Html exposing (Html)\n    import Html.Attributes as Attr\n    import Route\n    import Server.Request as Request\n    import Server.Response exposing (Response)\n\n    type alias SignupForm =\n        { email : String\n        , password : String\n        }\n\n    signupForm : Form.HtmlForm String SignupForm () Msg\n    signupForm =\n        Form.form\n            (\\email password passwordConfirmation ->\n                { combine =\n                    Validation.succeed SignupForm\n                        |> Validation.andMap email\n                        |> Validation.andMap\n                            (Validation.map2\n                                (\\passwordValue confirmationValue ->\n                                    if passwordValue == confirmationValue then\n                                        Validation.succeed passwordValue\n\n                                    else\n                                        passwordConfirmation\n                                            |> Validation.fail\n                                                \"Must match password\"\n                                )\n                                password\n                                passwordConfirmation\n                                |> Validation.andThen identity\n                            )\n                , view =\n                    \\info ->\n                        [ Html.label []\n                            [ fieldView info \"Email\" email\n                            , fieldView info \"Password\" password\n                            , fieldView info \"Confirm Password\" passwordConfirmation\n                            ]\n                        , Html.button []\n                            [ if info.submitting then\n                                Html.text \"Signing Up...\"\n\n                              else\n                                Html.text \"Sign Up\"\n                            ]\n                        ]\n                }\n            )\n            |> Form.field \"email\"\n                (Field.text\n                    |> Field.required \"Required\"\n                )\n            |> Form.field \"password\"\n                passwordField\n            |> Form.field \"passwordConfirmation\"\n                passwordField\n\n    passwordField =\n        Field.text\n            |> Field.password\n            |> Field.required \"Required\"\n            |> Field.withClientValidation\n                (\\password ->\n                    ( Just password\n                    , if String.length password < 4 then\n                        [ \"Must be at least 4 characters\" ]\n\n                      else\n                        []\n                    )\n                )\n\n    fieldView :\n        Form.Context String input\n        -> String\n        -> Validation.Field String parsed FieldView.Input\n        -> Html msg\n    fieldView formState label field =\n        Html.div []\n            [ Html.label []\n                [ Html.text (label ++ \" \")\n                , field |> Form.FieldView.input []\n                ]\n            , (if formState.submitAttempted then\n                formState.errors\n                    |> Form.errorsForField field\n                    |> List.map\n                        (\\error ->\n                            Html.li [] [ Html.text error ]\n                        )\n\n               else\n                []\n              )\n                |> Html.ul [ Attr.style \"color\" \"red\" ]\n            ]\n\n\n## Building a Form Parser\n\n@docs Form, HtmlForm, StyledHtmlForm\n\n@docs form\n\n\n### Adding Fields\n\n@docs field\n\n\n## View Functions\n\n@docs Context\n\n\n## Showing Errors\n\n@docs Errors, errorsForField\n\n\n## Rendering Forms\n\n@docs renderHtml, renderStyledHtml\n\n\n## Render Options\n\n@docs Options, options\n\n@docs withInput, withAction, withOnSubmit, withServerResponse\n\n@docs withGetMethod\n\n@docs Method, methodToString\n\n\n## Running Parsers\n\n@docs parse\n\n@docs Validated\n\n\n## Progressively Enhanced Form Techniques (elm-pages)\n\n\n### Hidden Fields\n\nHidden fields are a useful technique when you are progressively enhancing form submissions and sending the key-value form data directly.\nIn `elm-pages` apps this is used often and is an idiomatic approach. If you are wiring up your own `onSubmit` with a Msg\nand never submit the forms directly, then you will likely include additional context as part of your `Msg` instead of\nthrough hidden fields.\n\n@docs hiddenField, hiddenKind\n\n\n## Dynamic Fields\n\n@docs dynamic\n\n\n## Wiring\n\n`elm-form` manages the client-side state of fields, including FieldStatus which you can use to determine when\nin the user's workflow to show validation errors.\n\n@docs Msg, init, update\n\n\n### Model\n\n@docs Model, FormState, FieldState\n\n@docs ServerResponse\n\n@docs mapMsg, toResult\n\n","unions":[{"name":"Errors","comment":" The current validation errors for the given `Form`.\nYou can get the errors for a specific field using [`errorsForField`](#errorsForField).\n","args":["error"],"cases":[]},{"name":"Method","comment":" An HTTP method to use for the form submission. The default when you build `Options` with [`Form.options`](#options) is `Post`.\n\nSee <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#method> for more about the default browser behavior.\n\nNote that the default browser behavior can be simulated with client-side code using progress enhancement principles, but\nyou'll need to implement that yourself to get that same behavior unless you're using a framework that has it built in like `elm-pages`.\n\n","args":[],"cases":[["Get",[]],["Post",[]]]},{"name":"Validated","comment":" Parsing a `Form` will either give you a `Valid` type with the parsed value (nothing went wrong), or else\nan `Invalid` type if it encountered any validation errors. The `Invalid` type contains a Dict of errors (the keys are the field names).\n\nThe `Invalid` data also contains the parsed value if it is able to parse it. For example, if you have a Field defined with\n\n    Form.form\n        (\\checkin ->\n            { combine =\n                Validation.succeed Checkin\n                    |> Validation.andMap checkin\n            , view = [{- ... view here -}]\n            }\n        )\n        |> Form.field \"checkin\"\n            (Field.time { invalid = \\_ -> \"Invalid time value\" }\n                |> Field.withMin\n                    { hours = 10\n                    , minutes = 0\n                    }\n                    \"Check-in must be after 10\"\n                |> Field.withMax\n                    { hours = 12\n                    , minutes = 0\n                    }\n                    \"Check-in must be before noon\"\n            )\n\nA time of `7:23` would be parsed as `Invalid (Just { hours = 7, minutes = 23 }) (Dict.fromList [ ( \"checkin\", [ \"Check-in must be after 10\" ] ) ])`.\nBecause the `Field.withMin` validation is recoverable, it is able to add a validation error while still successfully parsing to a `Time` value.\n\n","args":["error","value"],"cases":[["Valid",["value"]],["Invalid",["Maybe.Maybe value","Dict.Dict String.String (List.List error)"]]]}],"aliases":[{"name":"Context","comment":" The data available as the first parameter in a Form's `view` function.\n","args":["error","input"],"type":"{ errors : Form.Errors error, submitting : Basics.Bool, submitAttempted : Basics.Bool, input : input }"},{"name":"FieldState","comment":" The state for an individual form field. Since `elm-form` manages state for you, it tracks both the values and [`FieldStatus`](Form-Validation#FieldStatus)\nfor all fields.\n","args":[],"type":"{ value : String.String, status : Form.Validation.FieldStatus }"},{"name":"Form","comment":" A `Form` definition represents\n\n  - The fields of the form\n  - How to render a form's fields into a `view`, and\n  - How to `combine` the fields into a parsed value\n\nA `Form` can be used to:\n\n\n### Render Form\n\n  - Render a `<form>` tag (using [`renderHtml`](#renderHtml) or [`renderStyledHtml`](#renderStyledHtml))\n\n\n### Parse Form\n\n  - [`parse`](#parse) into a [`Validated`](#Validated) value\n  - You can attempt to parse one of multiple `Form` definitions using [`Form.Handler`](Form-Handler).\n\nWhile you almost always will want to render your `Form` in your `view` function, you may also want to parse your form in a few more advanced use cases.\n\nIn a full-stack Elm application, you can try parsing with your Form definition since you can use code sharing to share the same `Form` definition between your frontend and backend.\n`elm-pages` has several built-in functions to help with this.\n\nYou may also want to parse your form data in your frontend to take in-flight form submissions and parse them into your parsed values.\n\n","args":["error","combineAndView","parsed","input"],"type":"Internal.Form.Form error combineAndView parsed input"},{"name":"FormState","comment":" The state for an individual `Form`. [`Model`](#Model) is a `Dict String FormState`, so it can contain the state for multiple forms.\n","args":[],"type":"{ fields : Dict.Dict String.String Form.FieldState, submitAttempted : Basics.Bool }"},{"name":"HtmlForm","comment":" A `Form` that renders to `elm/html`. Can be rendered with [`renderHtml`](#renderHtml).\n","args":["error","parsed","input","msg"],"type":"Form.Form error { combine : Pages.Internal.Form.Validation error parsed Basics.Never Basics.Never, view : Form.Context error input -> List.List (Html.Html msg) } parsed input"},{"name":"Model","comment":" The state for all forms. This is a single value that can be used to manage your form state, so when you render your\n`Form`s you will get client-side validations based on the state managed through this value. The state that is\nincluded here for each Form is:\n\n  - Whether submit has been attempted on the form\n  - The current value of each field in the form\n  - The current [`Form.Validation.FieldStatus`](Form-Validation#FieldStatus) for each field in the form\n\nSince this manages the state of multiple Forms, you can even maintain this in your application-wide `Model` rather than\nin a page-specific `Model`. In an `elm-pages` application, this is managed through the framework, but you can achieve\na similar wiring by managing the `Form.Model` globally.\n\nIn more advanced cases, you can manually modify the state of a form. However, it's often enough to just let this package\nmanage the state for you through the [`Form.update`](Form#update) function. Since this is a `Dict String FormState`, you can use `Dict` operations to clear or update\nthe state of forms if you need to manually manage form state.\n\n","args":[],"type":"Dict.Dict String.String Form.FormState"},{"name":"Msg","comment":" When you render a `Form` using [`Form.renderHtml`](#renderHtml) or [`Form.renderStyledHtml`](#renderStyledHtml),\nyou will pass in a `toMsg` to turn a `Form.Msg` into your application's `Msg`. That means you'll often have a `Msg` type like\n\n    import Form\n\n    type Msg\n        = FormMsg Form.Msg\n\n    -- | ... other Msg's\n\nIn an `elm-pages` application, you will render your `Form` using `Pages.Form.renderHtml` (or renderStyledHtml) and the msg type\nis a `PagesMsg.PagesMsg`, which is a framework-provided Msg with all of the glue handled at the framework-level. You can also\nuse a similar pattern in your own applications to reduce the wiring for each new page in your app.\n\n","args":["msg"],"type":"Internal.FieldEvent.Msg msg"},{"name":"Options","comment":" The Options for rendering a `Form`. You can build up `Options` by initializing the default Options with [`init`](#init)\nand then adding options with functions from [Render Options](#render-options) like [`withInput`](#withInput), [`withOnSubmit`](#withOnSubmit), etc.\n","args":["error","parsed","input","msg","extras"],"type":"{ id : String.String, action : Maybe.Maybe String.String, method : Form.Method, input : input, onSubmit : Maybe.Maybe ({ fields : List.List ( String.String, String.String ), method : Form.Method, action : String.String, parsed : Form.Validated error parsed } -> msg), serverResponse : Maybe.Maybe (Form.ServerResponse error), extras : Maybe.Maybe extras }"},{"name":"ServerResponse","comment":" The `persisted` state will be ignored if the client already has a form state. It is useful for persisting state between page loads. For example, `elm-pages` server-rendered routes\nuse this `persisted` state in order to show client-side validations and preserve form field state when a submission is done with JavaScript disabled in the user's browser.\n\n`serverSideErrors` will show on the client-side error state until the form is re-submitted. For example, if you need to check that a username is unique, you can do so by including\nan error in `serverSideErrors` in the response back from the server. The client-side form will show the error until the user changes the username and re-submits the form, allowing the\nserver to re-validate that input.\n\n","args":["error"],"type":"{ persisted : { fields : Maybe.Maybe (List.List ( String.String, String.String )), clientSideErrors : Maybe.Maybe (Dict.Dict String.String (List.List error)) }, serverSideErrors : Dict.Dict String.String (List.List error) }"},{"name":"StyledHtmlForm","comment":" A `Form` that renders to [`rtfeldman/elm-css`](https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/). Can be rendered with [`renderStyledHtml`](#renderStyledHtml).\n","args":["error","parsed","input","msg"],"type":"Form.Form error { combine : Pages.Internal.Form.Validation error parsed Basics.Never Basics.Never, view : Form.Context error input -> List.List (Html.Styled.Html msg) } parsed input"}],"values":[{"name":"dynamic","comment":" Allows you to render a Form that renders a sub-form based on the `decider` value.\n\nFor example, here is a `Form` that shows a dropdown to select between a `Post` and a `Link`, and then\nrenders the `linkForm` or `postForm` based on the dropdown selection.\n\n    import Form.Handler\n    import Form.Validation as Validation\n    import Form.Field as Field\n\n    type PostAction\n        = ParsedLink String\n        | ParsedPost { title : String, body : Maybe String }\n\n\n    type PostKind\n        = Link\n        | Post\n\n    dependentForm : Form.HtmlForm String PostAction input msg\n    dependentForm =\n        Form.form\n            (\\kind postForm_ ->\n                { combine =\n                    kind\n                        |> Validation.andThen postForm_.combine\n                , view = \\_ -> []\n                }\n            )\n            |> Form.field \"kind\"\n                (Field.select\n                    [ ( \"link\", Link )\n                    , ( \"post\", Post )\n                    ]\n                    (\\_ -> \"Invalid\")\n                    |> Field.required \"Required\"\n                )\n            |> Form.dynamic\n                (\\parsedKind ->\n                    case parsedKind of\n                        Link -> linkForm\n                        Post -> postForm\n                )\n\n    linkForm : Form.HtmlForm String PostAction input msg\n    linkForm =\n        Form.form\n            (\\url ->\n                { combine =\n                    Validation.succeed ParsedLink\n                        |> Validation.andMap url\n                , view = \\_ -> []\n                }\n            )\n            |> Form.field \"url\"\n                (Field.text\n                    |> Field.required \"Required\"\n                    |> Field.url\n                )\n\n\n    postForm : Form.HtmlForm String PostAction input msg\n    postForm =\n        Form.form\n            (\\title body ->\n                { combine =\n                    Validation.succeed\n                        (\\titleValue bodyValue ->\n                            { title = titleValue\n                            , body = bodyValue\n                            }\n                        )\n                        |> Validation.andMap title\n                        |> Validation.andMap body\n                        |> Validation.map ParsedPost\n                , view = \\_ -> []\n                }\n            )\n            |> Form.field \"title\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"body\" Field.text\n\n\n    Form.Handler.run\n        [ ( \"kind\", \"link\" )\n        , ( \"url\", \"https://elm-radio.com/episode/wrap-early-unwrap-late\" )\n        ]\n        (dependentForm |> Form.Handler.init identity)\n\n    --> (Valid (ParsedLink \"https://elm-radio.com/episode/wrap-early-unwrap-late\"))\n\n","type":"(decider -> Form.Form error { combine : Pages.Internal.Form.Validation error parsed named constraints1, view : subView } parsed input) -> Form.Form error ({ combine : decider -> Pages.Internal.Form.Validation error parsed named constraints1, view : decider -> subView } -> combineAndView) parsed input -> Form.Form error combineAndView parsed input"},{"name":"errorsForField","comment":" Get the List of errors for a given field.\n\nOften it's helpful to define a helper function for rendering a fields errors using your application's layout and style\nconventions.\n\n    import Form\n    import Form.Validation as Validation\n    import Html exposing (Html)\n\n    errorsView :\n        Form.Context String input\n        -> Validation.Field String parsed kind\n        -> Html msg\n    errorsView { submitAttempted, errors } field =\n        if submitAttempted || Validation.statusAtLeast Validation.Blurred field then\n            -- only show validations when a field has been blurred\n            -- (it can be annoying to see errors while you type the initial entry for a field, but we want to see the current\n            -- errors once we've left the field, even if we are changing it so we know once it's been fixed or whether a new\n            -- error is introduced)\n            errors\n                |> Form.errorsForField field\n                |> List.map\n                    (\\error ->\n                        Html.li\n                            [ Html.Attributes.style \"color\" \"red\" ]\n                            [ Html.text error ]\n                    )\n                |> Html.ul []\n\n        else\n            Html.ul [] []\n\n","type":"Form.Validation.Field error parsed kind -> Form.Errors error -> List.List error"},{"name":"field","comment":" Declare a visible field for the form.\n\nUse [`Form.Field`](Form-Field) to define the field and its validations.\n\n    form =\n        Form.form\n            (\\email ->\n                { combine =\n                    Validation.succeed SignupForm\n                        |> Validation.andMap email\n                , view = \\info -> [{- render fields -}]\n                }\n            )\n            |> Form.field \"email\"\n                (Field.text |> Field.required \"Required\")\n\n","type":"String.String -> Form.Field.Field error parsed input initial kind constraints -> Form.Form error (Form.Validation.Field error parsed kind -> combineAndView) parsedCombined input -> Form.Form error combineAndView parsedCombined input"},{"name":"form","comment":" Initialize the builder for a `Form`. Typically an anonymous function is passed in to this function, with one\nparameter for each field that comes after.\n\n    form =\n        Form.form\n            (\\name email ->\n                { combine =\n                    Validation.succeed User\n                        |> Validation.andMap name\n                        |> Validation.andMap email\n                , view = \\info -> [{- render fields -}]\n                }\n            )\n            |> Form.field \"name\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"email\" (Field.text |> Field.required \"Required\")\n\n","type":"combineAndView -> Form.Form error combineAndView parsed input"},{"name":"hiddenField","comment":" Declare a hidden field for the form.\n\nUnlike [`field`](#field) declarations which are rendered using [`Form.FieldView`](Form-FieldView)\nfunctions, `hiddenField` inputs are automatically inserted into the form when you render it.\n\nYou define the field's validations the same way as for `field`, with the\n[`Form.Field`](Form-Field) API.\n\n    form =\n        Form.form\n            (\\quantity productId ->\n                { combine = {- combine fields -}\n                , view = \\info -> [{- render visible fields -}]\n                }\n            )\n            |> Form.field \"quantity\"\n                (Field.int |> Field.required \"Required\")\n            |> Form.field \"productId\"\n                (Field.text\n                    |> Field.required \"Required\"\n                    |> Field.withInitialValue (\\product -> Form.Value.string product.id)\n                )\n\n","type":"String.String -> Form.Field.Field error parsed input initial kind constraints -> Form.Form error (Form.Validation.Field error parsed Form.FieldView.Hidden -> combineAndView) parsedCombined input -> Form.Form error combineAndView parsedCombined input"},{"name":"hiddenKind","comment":" Like [`hiddenField`](#hiddenField), but uses a hardcoded value. This is useful to ensure that your [`Form.Handler`](Form-Handler)\nis parsing the right kind of Form when there is more than one kind of Form on a given page.\n\n    updateProfile : Form.HtmlForm String ( String, String ) input msg\n    updateProfile =\n        Form.form\n            (\\first last ->\n                { combine =\n                    Validation.succeed Tuple.pair\n                        |> Validation.andMap first\n                        |> Validation.andMap last\n                , view = \\_ -> []\n                }\n            )\n            |> Form.field \"first\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"last\" (Field.text |> Field.required \"Required\")\n            |> Form.hiddenKind ( \"kind\", \"update-profile\" ) \"Expected kind\"\n\n","type":"( String.String, String.String ) -> error -> Form.Form error combineAndView parsed input -> Form.Form error combineAndView parsed input"},{"name":"init","comment":" Initialize the [`Form.Model`](Form#Model).\n\n    import Form\n\n    init : Flags -> ( Model, Cmd Msg )\n    init flags =\n        ( { formModel = Form.init\n          , submitting = False\n          }\n        , Cmd.none\n        )\n\n","type":"Form.Model"},{"name":"mapMsg","comment":" Lets you map a user msg within a `Form.Msg`.\n","type":"(msg -> msgMapped) -> Form.Msg msg -> Form.Msg msgMapped"},{"name":"methodToString","comment":" Turn a `Method` into \"GET\" or \"POST\".\n","type":"Form.Method -> String.String"},{"name":"options","comment":" Initialize a set of default options with a unique `id` for your Form. Note that even if you are rendering the same form\nmultiple times this ID needs to be unique in order to manage the state of each form independently.\n\nFor example,\n\n    cartView model items =\n        items\n            |> List.map\n                (\\item ->\n                    itemForm\n                        |> Form.renderHtml\n                            { submitting = model.submitting\n                            , state = model.formState\n                            , toMsg = FormMsg\n                            }\n                            (Form.options (\"cart-item-\" ++ item.id))\n                            []\n                )\n            |> Html.div []\n\n","type":"String.String -> Form.Options error parsed () msg extras"},{"name":"parse","comment":" Try parsing the `Form`. Usually not needed directly, usually it's better to use [`Form.Handler`](Form-Handler)\nto try parsing one of multiple `Form`s.\n","type":"String.String -> Form.Model -> input -> Form.Form error { info | combine : Pages.Internal.Form.Validation error parsed named constraints } parsed input -> Form.Validated error parsed"},{"name":"renderHtml","comment":" Render the form to `elm/html`.\n\n    view model =\n        signUpForm\n            |> Form.renderHtml\n                { submitting = model.submitting\n                , state = model.formState\n                , toMsg = FormMsg\n                }\n                (Form.options \"signUpForm\")\n                []\n\nNote: In `elm-pages`, you'll want to use the `Pages.Form.renderHtml` function instead.\n\n","type":"{ submitting : Basics.Bool, state : Form.Model, toMsg : Form.Msg mappedMsg -> mappedMsg } -> Form.Options error parsed input mappedMsg extras -> List.List (Html.Attribute mappedMsg) -> Form.Form error { combine : Pages.Internal.Form.Validation error parsed named constraints, view : Form.Context error input -> List.List (Html.Html mappedMsg) } parsed input -> Html.Html mappedMsg"},{"name":"renderStyledHtml","comment":" Render the form to [`rtfeldman/elm-css`](https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/).\n\n    view model =\n        signUpForm\n            |> Form.renderStyledHtml\n                { submitting = model.submitting\n                , state = model.formState\n                , toMsg = FormMsg\n                }\n                (Form.options \"signUpForm\")\n                []\n\nNote: In `elm-pages`, you'll want to use the `Pages.Form.renderStyledHtml` function instead.\n\n","type":"{ submitting : Basics.Bool, state : Form.Model, toMsg : Form.Msg mappedMsg -> mappedMsg } -> Form.Options error parsed input mappedMsg extras -> List.List (Html.Styled.Attribute mappedMsg) -> Form.Form error { combine : Pages.Internal.Form.Validation error parsed field constraints, view : Form.Context error input -> List.List (Html.Styled.Html mappedMsg) } parsed input -> Html.Styled.Html mappedMsg"},{"name":"toResult","comment":" Parsing a `Form` gives you a [`Validated`](#Validated) type. This helper turns it into a `Result`\nthat is semantically the same. This can be useful for using a parsed `Form` value in a pipeline.\n","type":"Form.Validated error value -> Result.Result ( Maybe.Maybe value, Dict.Dict String.String (List.List error) ) value"},{"name":"update","comment":" Update the `Form.Model` given the `Form.Msg` and the previous `Form.Model`. See the\n[README's section on Wiring](./#wiring).\n","type":"Form.Msg msg -> Form.Model -> ( Form.Model, Platform.Cmd.Cmd msg )"},{"name":"withAction","comment":" Set the `action` attribute of the rendered `<form>` element. Note that the `action` attribute in the `withOnSubmit` is preprocessed in the browser, so the String will point to the same URL but\nwon't necessarily be the exact same String that was passed in. For example, if you set `options |> Form.withAction \"/login\"`, your onSubmit will receive an absolute URL such as `{ action = \"https://mysite.com/login\" {- , ... -} }`.\n\nSetting the `action` can be useful if you are progressively enhancing form behavior. The default browser form submission behavior is to submit to the current URL if no `action` attribute is set, and an `action` is present\nthen the form submission will go to the given URL. If you are attempting to use progressive enhancement then you can simulate this behavior through your `withOnSubmit` handler, or you may be using a framework that has this simulation built in like `elm-pages`.\n\nSee also <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#action>.\n\n","type":"String.String -> Form.Options error parsed input msg extras -> Form.Options error parsed input msg extras"},{"name":"withGetMethod","comment":" The default Method from `options` is `Post` since that is the most common. The `Get` Method for form submissions will add the form fields as a query string and navigate to that route using a GET.\nYou will need to progressively enhance your onSubmit to simulate this browser behavior if you want something similar, or use a framework that has this simulation built in like `elm-pages`.\n","type":"Form.Options error parsed input msg extras -> Form.Options error parsed input msg extras"},{"name":"withInput","comment":" You can pass in an `input` value to the `Options` that are passed in to [`renderHtml`](#renderHtml) or [`renderStyledHtml`](#renderStyledHtml).\n\nYou can use whichever data type you want as your `input` value. You will then have access to that value in two places:\n\n1.  The Form's `view` through the [`Context`](#Context) argument's `input` field.\n2.  [`Form.Field.withInitialValue`](Form-Field#withInitialValue)\n\nOne example where you would use an `input` value is if you have an existing UserProfile from the server that you want to use to pre-populate the form fields.\n\n    import Form\n    import Form.Field as Field\n    import Form.Validation as Validation\n\n    type alias UserProfile =\n        { name : String\n        , email : String\n        }\n\n    userProfileForm : Form.HtmlForm String UserProfile UserProfile msg\n    userProfileForm =\n        (\\name email ->\n            { combine =\n                Validation.succeed UserProfile\n                    |> Validation.andMap name\n                    |> Validation.andMap email\n            , view =\n                \\context ->\n                    [ Html.h2\n                        []\n                        [ Html.text\n                            --  use the input to display Model data\n                            (context.input\n                                ++ \"'s Profile\"\n                            )\n                        ]\n                    , fieldView \"Name\" name\n                    , fieldView \"Email\" email\n                    , if context.submitting then\n                        Html.button [ Html.Attributes.disabled True ] [ Html.text \"Updating...\" ]\n\n                      else\n                        Html.button [] [ Html.text \"Update\" ]\n                    ]\n            }\n        )\n            |> Form.form\n            |> Form.field \"name\"\n                (Field.text\n                    |> Field.required \"Required\"\n                    |> Field.withInitialValue .name\n                )\n            |> Form.field \"email\"\n                (Field.text\n                    |> Field.required \"Required\"\n                    |> Field.withInitialValue .email\n                )\n\n    view model =\n        [ model.userProfile\n            |> Maybe.map\n                (\\userProfile ->\n                    userProfileForm\n                        |> Form.renderHtml\n                            { submitting = model.submitting\n                            , state = model.formState\n                            , toMsg = FormMsg\n                            }\n                            (Form.options \"userProfile\"\n                                |> Form.withInput userProfile\n                            )\n                            []\n                )\n            |> Maybe.withDefault \"Loading Profile...\"\n        ]\n\n","type":"input -> Form.Options error parsed () msg extras -> Form.Options error parsed input msg extras"},{"name":"withOnSubmit","comment":" You can add an onSubmit handler to the Form's `Options`. If you are using a framework that is integrated with `elm-form` (such as `elm-pages`), then you can\nrely on the framework's onSubmit behavior. Otherwise, you will need to do something with the form when there is a valid form submission.\n\nThere are a few different approaches you can use.\n\n1.  Progressively enhance the raw FormData submission. Since `withOnSubmit` gives you access to `{ fields : List ( String, String ) {- ... -} }`, you can propagate the raw key-value pairs (`fields`) and send those to your API. If you are doing full-stack Elm with `elm-pages` or Lamdera, then this can be a great fit because you can do code sharing and re-use your `Form` definition on the backend to parse the raw FormData. However, you may not want to use this approach with frontend-only Elm because you may prefer to communicate with your backend using more structured data like JSON rather than FormData (which is just key-value strings).\n2.  Parse into your preferred type, then with an on-submit Msg, check if the data is `Valid`, and if it is, use the parsed data to make a request to your API (by JSON-encoding the value, building a GraphQL request, etc.).\n3.  In your Form's `combine`, directly parse into a representation of your request, such as a `Json.Encode.Value`, a `Cmd Msg`, a `Task error Msg`, or an intermediary data type that represents an API request.\n\nLet's look at an example of approach (3). In this example, we define a `Request` record alias which represents an API request. Note, there is nothing special about this `Request` type, this is just\nan example ot illustrate this general pattern, but consider the best types for your use case when you adapt this example for your app.\n\n    import Form\n    import Form.Field as Field\n    import Form.Validation as Validation\n\n    type alias Request =\n        { path : String\n        , body : Encode.Value\n        , expect : Http.Expect Msg\n        }\n\n    sendRequest : Request -> Cmd Msg\n    sendRequest request =\n        Http.post\n            { url = \"https://myservice.com/api\" ++ request.path\n            , body = Http.jsonBody request.body\n            , expect = request.expect\n            }\n\n    userProfileForm : Form.HtmlForm String Request input msg\n    userProfileForm =\n        (\\name email ->\n            { combine =\n                Validation.succeed\n                    (\\nameValue emailValue ->\n                        { path = \"/api/user\"\n                        , body =\n                            Encode.object\n                                [ ( \"name\", Encode.string nameValue )\n                                , ( \"email\", Encode.string emailValue )\n                                ]\n                        }\n                    , expect = Http.expectJson GotUpdatedProfile profileDecoder\n                    )\n                    |> Validation.andMap name\n                    |> Validation.andMap email\n            , view = \\context -> [{- ... view here -}]\n            }\n        )\n            |> Form.form\n            |> Form.field \"name\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"email\" (Field.text |> Field.required \"Required\")\n\n","type":"({ fields : List.List ( String.String, String.String ), method : Form.Method, action : String.String, parsed : Form.Validated error parsed } -> msg) -> Form.Options error parsed input oldMsg extras -> Form.Options error parsed input msg extras"},{"name":"withServerResponse","comment":" You can render your `Form` with an initial set of values and errors that semantically represent a server response.\n\nConceptually, this is like sending a traditional form submission to a backend. When this happens in a `<form>` with no\nJavaScript event handlers, the server responds with a new page load, and that newly rendered page needs to contain any\nfield errors and persist any field values that were submitted so the user can continue filling out their form.\n\nIn an `elm-pages` app, you can submit your forms with JavaScript turned off and see this exact behavior, but you need to\nbe sure to wire in a `ServerResponse` so that the form state is persisted in the freshly rendered page.\n\nYou can also use this `ServerResponse` to send down server-side errors, especially if you are using full-stack Elm.\n\n","type":"Maybe.Maybe (Form.ServerResponse error) -> Form.Options error parsed input msg extras -> Form.Options error parsed input msg extras"}],"binops":[]},{"name":"Form.Field","comment":"\n\n@docs Field\n\n\n## Base Fields\n\n@docs text, checkbox, int, float\n\n\n## Multiple Choice Fields\n\n@docs select, OutsideRange\n\n\n## Date/Time Fields\n\n@docs date, time, TimeOfDay\n\n\n## Initial Values\n\n@docs withInitialValue, withOptionalInitialValue\n\n\n## Other\n\n@docs exactValue\n\n\n## Field Configuration\n\n@docs required, validateMap, map\n\n\n## Text Field Display Options\n\n@docs email, password, search, telephone, url, textarea\n\n\n## Numeric Field Options\n\n@docs range, withMin, withMax\n\n@docs withMinLength, withMaxLength\n\n@docs withStep\n\n\n## Phantom Options\n\n@docs No, Yes\n\n","unions":[{"name":"No","comment":" Used in the constraints for a Field. These can't be built or used outside of the API, they are only used as guardrails\n\nto ensure sure that Fields are configured correctly.\n\n","args":[],"cases":[]},{"name":"OutsideRange","comment":" Used for errors from a [`range`](#range) Field.\n","args":[],"cases":[["AboveRange",[]],["BelowRange",[]]]},{"name":"Yes","comment":" Used in the constraints for a Field. These can't be built or used outside of the API, they are only used as guardrails\nto ensure sure that Fields are configured correctly.\n","args":[],"cases":[]}],"aliases":[{"name":"Field","comment":" A `Field` represents the base information of how to turn a raw input into a parsed value, and how to display that value\nas an HTML form field element. Note that you can also perform more advanced validations and mapping using the\n[`Form.Validation`](Form-Validation) API in your `combine` function.\n\nFor example, if you want to display a check-in and check-out date field, you would use `date` Fields. Using [`date`](#date)\ndoes two things:\n\n1.  Sets display options for the browser to display the field with [`<input type=\"date\">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date).\n\n2.  Parses into an Elm value of type [`Date`](https://package.elm-lang.org/packages/justinmimbs/date/latest/Date#Date) (or a validation error if the format isn't invalid).\n\nWhy would the date format be invalid if it is managed by the Browser's date picker element? In the happy path on the Browser this will never happen.\n\nHowever, you can't make any assumptions about the client (non-standard clients could be used), or about the data format that is sent to servers.\nOften validation logic is duplicated to guard against this on both the client (display useful validation feedback for the user) and the server (validate untrusted input).\nIf you use full-stack Elm, you can use your Form definition on your server to run the same code that\nyou use to present validation errors on the client, allowing you to keep the validations in sync.\n\nHere is an example that showcases different types of Fields (`text`, `date`, `time`, and `checkbox`), as well as how to use the `combine` function to\ntransform the parsed values and perform additional validations between the parsed fields.\n\n    import Date exposing (Date)\n    import Form\n    import Form.Field as Field\n    import Form.Validation as Validation\n\n    type alias Stay =\n        { name : String\n        , checkIn : Checkin\n        , emailUpdates : Bool\n        }\n\n    type alias Checkin =\n        { date : Date\n        , nights : Int\n        , time : TimeOfDay\n        }\n\n    example : Form.HtmlForm String Stay input Msg\n    example =\n        (\\name checkIn checkOut checkInTime emailUpdates ->\n            { combine =\n                Validation.succeed Stay\n                    |> Validation.andMap name\n                    |> Validation.andMap\n                        (Validation.succeed\n                            (\\checkinValue checkoutValue checkInTimeValue ->\n                                Validation.succeed\n                                    { date = checkinValue\n                                    , nights = Date.toRataDie checkoutValue - Date.toRataDie checkinValue\n                                    , time = checkInTimeValue\n                                    }\n                                    |> Validation.withErrorIf (Date.toRataDie checkinValue >= Date.toRataDie checkoutValue) checkIn \"Must be before checkout\"\n                            )\n                            |> Validation.andMap checkIn\n                            |> Validation.andMap checkOut\n                            |> Validation.andMap checkInTime\n                            |> Validation.andThen identity\n                        )\n                    |> Validation.andMap emailUpdates\n            , view =\n                \\formState ->\n                    let\n                        fieldView label field =\n                            Html.div []\n                                [ Html.label []\n                                    [ Html.text (label ++ \" \")\n                                    , FieldView.input [] field\n                                    , errorsView formState field\n                                    ]\n                                ]\n                    in\n                    [ fieldView \"Name\" name\n                    , fieldView \"Check-In\" checkIn\n                    , fieldView \"Check-Out\" checkOut\n                    , fieldView \"Check-In Time\" checkInTime\n                    , fieldView \"Sign Up For Email Updates\" emailUpdates\n                    , Html.button [] [ Html.text \"Submit\" ]\n                    ]\n            }\n        )\n            |> Form.form\n            |> Form.field \"name\"\n                (Field.text\n                    |> Field.required \"Required\"\n                )\n            |> Form.field \"checkin\"\n                (Field.date\n                    { invalid = \\_ -> \"Invalid\" }\n                    |> Field.required \"Required\"\n                    |> Field.withMin today (\"Must be after \" ++ Date.toIsoString today)\n                )\n            |> Form.field \"checkout\"\n                (Field.date\n                    { invalid = \\_ -> \"Invalid\" }\n                    |> Field.required \"Required\"\n                )\n            |> Form.field \"checkinTime\"\n                (Field.time\n                    { invalid = \\_ -> \"Invalid\" }\n                    |> Field.required \"Required\"\n                    |> Field.withMin { hours = 10, minutes = 0 } \"Must be after today\"\n                )\n            |> Form.field \"emailUpdates\"\n                Field.checkbox\n\n    today : Date\n    today =\n        Date.fromRataDie 738624\n\nThe key concepts to understand here are where the view and validation logic for fields lives.\n\nThe `Form`'s `view` function is responsible for combining the rendered Fields, but the `Field` contains the information for how to display\nthe form field itself (details like like `<input type=\"date\">`, `<input type=\"checkbox\">`, `<textarea>` etc.). Since form fields contain both\ndisplay logic that changes how we parse/validate the field, all of the parsing and validation logic related to displaying the\nField is also defined with `Field` type. For example, `Field.withMin` contains information that is used both for displaying the form field and for\nvalidating it. When we set `Field.withMin`, it gives the Browser information on how to restrict the date picker UI from showing\ninvalid dates, but setting that minimum value also runs that validation when we run the Form parser, even if we run it\non a server through code sharing.\n\nNote that the validations in a `Field`s definition (such as `Field.withMin`, or `Field.date`, etc.) are run\nregardless of whether you use that field in the Form's `combine` function.\n\n","args":["error","parsed","input","initial","kind","constraints"],"type":"Internal.Field.Field error parsed input initial kind constraints"},{"name":"TimeOfDay","comment":" A time of day in 24-hour time.\n\nThe hours must be between 0 and 23, and the minutes must be between 0 and 59.\n\nThis is the type that a `time` field parses into, and is also used to set initial values and minimum/maximum values for `time`.\n\nSee <https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#time_strings>\n\n","args":[],"type":"{ hours : Basics.Int, minutes : Basics.Int, seconds : Maybe.Maybe Basics.Int }"}],"values":[{"name":"checkbox","comment":" Renders a checkbox input (`<input type=\"checkbox\">`), see <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox>.\n\n    import Form.Field as Field\n\n    example =\n        Field.checkbox\n\n","type":"Form.Field.Field error Basics.Bool input Basics.Bool Form.FieldView.Input { required : () }"},{"name":"date","comment":" A date field. Parses into a value of type [`Date`](https://package.elm-lang.org/packages/justinmimbs/date/latest/Date#Date).\n\n    example =\n        Field.date\n            { invalid = \\_ -> \"Invalid date\" }\n            |> Field.required \"Required\"\n            |> Field.withMin (Date.fromRataDie 738624) \"Must be after today\"\n            -- date picker will show dates on the same day of the week starting from the start date\n            |> Field.withStep 7\n\n","type":"{ invalid : String.String -> error } -> Form.Field.Field error (Maybe.Maybe Date.Date) input Date.Date Form.FieldView.Input { min : Date.Date, max : Date.Date, required : (), wasMapped : Form.Field.No, step : Basics.Int }"},{"name":"email","comment":" Modifier for [`text`](#text) Field. This does not perform any additional validations on the Field, it only provides a hint to the browser\nthat the Field should be displayed as an email input (`<input type=\"email\">`). This is especially useful for mobile devices to make sure\nthe correct keyboard is displayed.\n\nSee <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email>.\n\n    example =\n        Field.text\n            |> Field.email\n            |> Field.required \"Email is required\"\n\n","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"exactValue","comment":" Render a field with a hardcoded value.\n","type":"String.String -> error -> Form.Field.Field error String.String input Basics.Never Form.FieldView.Input { required : (), plainText : (), wasMapped : Form.Field.No }"},{"name":"float","comment":" A number input (`<input type=\"number\">`), see <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number>.\n\nUnlike [`int`](#int), this field allows floating point numbers.\nIt will give a validation error if the input is not a number, using the error value passed in through the `invalid` function.\n\n    import Form.Field as Field\n\n    example =\n        Field.number\n            { invalid =\n                \\value -> \"Must be a number\"\n            }\n\n","type":"{ invalid : String.String -> error } -> Form.Field.Field error (Maybe.Maybe Basics.Float) input Basics.Float Form.FieldView.Input { min : Basics.Float, max : Basics.Float, required : (), wasMapped : Form.Field.No }"},{"name":"int","comment":" Renders a number input (`<input type=\"number\">`), see <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number>.\n\nFloating point numbers will give a validation error, using the error value passed in through the `invalid` function.\n\n    import Form.Field as Field\n\n    example =\n        Field.number\n            { invalid =\n                \\value -> \"Must be an integer\"\n            }\n\n","type":"{ invalid : String.String -> error } -> Form.Field.Field error (Maybe.Maybe Basics.Int) input Basics.Int Form.FieldView.Input { min : Basics.Int, max : Basics.Int, required : (), wasMapped : Form.Field.No, step : Basics.Int }"},{"name":"map","comment":" Map the parsed value of a Field without adding or modifying its validations or rendering.\n\n    import Form.Field as Field\n\n    example =\n        Field.text\n            |> Field.required \"Required\"\n            |> Field.map String.toUpper\n\n","type":"(parsed -> mapped) -> Form.Field.Field error parsed input initial kind constraints -> Form.Field.Field error mapped input initial kind { constraints | wasMapped : Form.Field.Yes }"},{"name":"password","comment":" Modifier for [`text`](#text) Field. This is only a display hint to the browser that the Field should be displayed as a password input (`<input type=\"password\">`).\n\nSee <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/password>.\n\n    example =\n        Field.text\n            |> Field.password\n            |> Field.required \"Password is required\"\n\n","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"range","comment":" Display a range input (`<input type=\"range\">`). See <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range>.\n\n    import Form.Field as Field\n\n    type alias Settings =\n        { brightness : Int\n        }\n\n    example =\n        (\\brightness ->\n            { combine =\n                Validation.succeed Settings\n                    |> Validation.andMap brightness\n            , view = []\n            }\n        )\n            |> Form.form\n            |> Form.field \"brightness\"\n                (Field.range\n                    { min = 0\n                    , max = 100\n                    , missing = \"Required\"\n                    , invalid =\n                        \\outsideRange ->\n                            case outsideRange of\n                                Field.AboveRange ->\n                                    \"Must be below 100\"\n\n                                Field.BelowRange ->\n                                    \"Must be above 0\"\n                    }\n                    (Field.int { invalid = \\_ -> \"Invalid\" })\n                )\n\nCan be used with either [`int`](#int) or [`float`](#float).\n\n","type":"{ min : numberInitial, max : numberInitial, missing : error, invalid : Form.Field.OutsideRange -> error } -> Form.Field.Field error (Maybe.Maybe valueType) input numberInitial kind { constraints | required : (), min : numberInitial, max : numberInitial, wasMapped : Form.Field.No } -> Form.Field.Field error valueType input numberInitial Form.FieldView.Input { constraints | wasMapped : Form.Field.No }"},{"name":"required","comment":" Gives a validation error for fields that haven't been set, and removes the `Maybe` around the parsed value.\n\n    example =\n        Field.int { invalid = \\_ -> \"Invalid\" }\n            -- parses into `Maybe Int` before we call `required`\n            -- after `required`, it parses into an `Int`\n            |> Field.required \"Required\"\n\n","type":"error -> Form.Field.Field error (Maybe.Maybe parsed) kind input initial { constraints | required : (), wasMapped : Form.Field.No } -> Form.Field.Field error parsed kind input initial { constraints | wasMapped : Form.Field.No }"},{"name":"search","comment":" Modifier for [`text`](#text) Field. This changes the display of the Field to a password input (`<input type=\"search\">`).\nOn mobile devices, this will display a keyboard with a search button.\n\nSee <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/search>.\n\n    example =\n        Field.text\n            |> Field.search\n\n","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"select","comment":" An input for a set of possible options. Can be rendered in two ways\n\n  - As a dropdown (`<select>`)[`Form.FieldView.select`](Form-FieldView#select)\n  - As a set of radio buttons (`<input type=\"radio\">`)[`Form.FieldView.radio`](Form-FieldView#radio).\n\n```elm\nimport Form\nimport Form.Field as Field\nimport Form.FieldView as FieldView\nimport Form.Validation as Validation\n\nsizeForm : Form.HtmlForm String Size input msg\nsizeForm =\n    (\\size ->\n        { combine =\n            Validation.succeed identity\n                |> Validation.andMap size\n        , view =\n            \\formState ->\n                [ Html.div []\n                    [ FieldView.select []\n                        (\\entry -> ( [], sizeToString entry ))\n                        size\n                    ]\n                , Html.button [] [ Html.text \"Submit\" ]\n                ]\n        }\n    )\n        |> Form.form\n        |> Form.field \"size\"\n            (Field.select\n                [ ( \"small\", Small )\n                , ( \"medium\", Medium )\n                , ( \"large\", Large )\n                ]\n                (\\_ -> \"Invalid\")\n                |> Field.required \"Required\"\n                |> Field.withInitialValue (\\_ -> Small)\n            )\n\nsizeToString : Size -> String\nsizeToString size =\n    case size of\n        Small ->\n            \"Small\"\n\n        Medium ->\n            \"Medium\"\n\n        Large ->\n            \"Large\"\n\ntype Size\n    = Small\n    | Medium\n    | Large\n```\n\n","type":"List.List ( String.String, option ) -> (String.String -> error) -> Form.Field.Field error (Maybe.Maybe option) input option (Internal.Input.Options option) { required : (), wasMapped : Form.Field.No }"},{"name":"telephone","comment":" Modifier for [`text`](#text) Field. This is only a display hint to the browser (`<input type=\"tel\">`).\n\nThis is especially important on mobile devices for ensuring that the correct keyboard is displayed for inputting a phone number.\n\nSee <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/tel>.\n\n    example =\n        Field.text\n            |> Field.telephone\n\n","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"text","comment":" The base for a text field. You can add display modifiers to text fields, including displaying them as a `textarea`.\nSee [Text Field Display Options](#text-field-display-options).\n\nBy default, text fields are not required. If the field is not touched or has been deleted, the value will be `Nothing`\n(_not_ empty string `Just \"\"`). See [`required`](#required).\n\n    import Form.Field as Field\n\n    type alias Profile =\n        { status : Maybe String\n        }\n\n    example =\n        (\\username ->\n            { combine =\n                Validation.succeed Status\n                    |> Validation.andMap username\n            , view = []\n            }\n        )\n            |> Form.form\n            |> Form.field \"status\" Field.text\n\n","type":"Form.Field.Field error (Maybe.Maybe String.String) input String.String Form.FieldView.Input { required : (), plainText : (), wasMapped : Form.Field.No, minlength : (), maxlength : () }"},{"name":"textarea","comment":" Modifier for [`text`](#text) Field to display it as a [`textarea`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea).\n\n`textarea` are for multi-line text input. For example, you might use a regular `text` Field for a username, and a `textarea` Field for a biography.\n\n    import Form.Field as Field\n\n    type alias Profile =\n        { username : String\n        , bio : String\n        }\n\n    example =\n        (\\username bio ->\n            { combine =\n                Validation.succeed Profile\n                    |> Validation.andMap username\n                    |> Validation.andMap bio\n            , view = []\n            }\n        )\n            |> Form.form\n            |> Form.field \"username\"\n                (Field.text\n                    |> Field.required \"Required\"\n                )\n            |> Form.field \"bio\"\n                (Field.text\n                    |> Field.textarea\n                        { rows = Just 20\n                        , cols = Just 50\n                        }\n                    |> Field.required \"Required\"\n                )\n\n","type":"{ rows : Maybe.Maybe Basics.Int, cols : Maybe.Maybe Basics.Int } -> Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"time","comment":" <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/time>\n","type":"{ invalid : String.String -> error } -> Form.Field.Field error (Maybe.Maybe Form.Field.TimeOfDay) input Form.Field.TimeOfDay Form.FieldView.Input { min : Form.Field.TimeOfDay, max : Form.Field.TimeOfDay, required : (), wasMapped : Form.Field.No, step : Basics.Int }"},{"name":"url","comment":" Modifier for [`text`](#text) Field. This does not perform any additional validations on the Field, it only provides a hint to the browser\nthat the Field should be displayed as a URL input (`<input type=\"url\">`).\n\nSee <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/url>.\n\n    example =\n        Field.text\n            |> Field.url\n            |> Field.required \"URL is required\"\n\n","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"validateMap","comment":" Add a custom validation and/or transformation of the value to the field.\n\n    import Form.Field as Field\n\n    example =\n        Field.text\n            |> Field.required \"Required\"\n            |> Field.validateMap Username.fromString\n\n      -- in Username.elm\n      fromString : String -> Result String Username\n      fromString string =\n          if string |> String.contains \"@\" then\n              Err \"Must not contain @\"\n\n          else\n              Username string |> Ok\n\n","type":"(parsed -> Result.Result error mapped) -> Form.Field.Field error parsed input initial kind constraints -> Form.Field.Field error mapped input initial kind { constraints | wasMapped : Form.Field.Yes }"},{"name":"withInitialValue","comment":" Set an initial value for the `Field` given the `Form`'s `input` (see [`Form.withInput`](Form#withInput)).\nThis allows you to pass in dynamic state like values from your `Model`.\n\nThe initial value will be used until the field is modified by the user, and from there it is controlled by user input. If you\nneed to programmatically set a field's value for more advanced use cases, you can also modify the [`Form.Model`](Form#Model).\n\nThe type you use to set the initial value depends on the Field. For example, you can set a `checkbox` Field's initial value\nwith a `Bool`\n\n    example =\n        Form.checkbox |> Form.withInitialValue .autoplay\n\n    formOptions : { autoplay : Bool } -> Form.Options String parsed { autoplay : Bool } msg\n    formOptions currentSettings =\n        Form.options \"settings\"\n            |> Form.withInput currentSettings\n\nNote that the type used to set the initial value is independent of types you might `map` a field into.\n\n","type":"(input -> initial) -> Form.Field.Field error value input initial kind constraints -> Form.Field.Field error value input initial kind constraints"},{"name":"withMax","comment":" Same as [`withMin`](#withMin) but for a maximum value. See <https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/max>.\n\n    import Date exposing (Date)\n    import Form.Field as Field\n\n    example =\n        Field.date\n            { invalid = \\_ -> \"Must be valid date\" }\n            |> Field.required \"Required\"\n            |> Field.withMax today \"Cannot schedule more than 7 days in advance\"\n\n    inAWeek : Date\n    inAWeek =\n        Date.fromRataDie (today + 7)\n\n    today : Int\n    today =\n        738624\n\n","type":"initial -> error -> Form.Field.Field error parsed input initial kind { constraints | max : initial } -> Form.Field.Field error parsed input initial kind constraints"},{"name":"withMaxLength","comment":" Set a maximum length for the string. See <https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/maxlength>.\n","type":"Basics.Int -> error -> Form.Field.Field error parsed input initial kind { constraints | maxlength : () } -> Form.Field.Field error parsed input initial kind constraints"},{"name":"withMin","comment":" Set the min value for the Field. This results in both a validation (run on the server as well as the client) as well as a display hint to the browser\n(`<input type=\"date\" min=\"2023-04-14\">`). The Browser will prevent the user from entering a value below the min value in some cases but not all.\n\nSee <https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/min>.\n\nIf the value is invalid (below the minimum), the error will be whichever error is passed in as the second argument.\n\n    import Date exposing (Date)\n    import Form.Field as Field\n\n    example =\n        Field.date\n            { invalid = \\_ -> \"Must be valid date\" }\n            |> Field.required \"Required\"\n            |> Field.withMin today (\"Must be after \" ++ Date.toIsoString today)\n\n    today : Date\n    today =\n        Date.fromRataDie 738624\n\n","type":"initial -> error -> Form.Field.Field error parsed input initial kind { constraints | min : initial } -> Form.Field.Field error parsed input initial kind constraints"},{"name":"withMinLength","comment":" Set a minimum length for the string. See <https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/minlength>.\n","type":"Basics.Int -> error -> Form.Field.Field error parsed input initial kind { constraints | minlength : () } -> Form.Field.Field error parsed input initial kind constraints"},{"name":"withOptionalInitialValue","comment":" Similar to [`withInitialValue`](#withInitialValue), but takes in a `Maybe` value. If the `Maybe` is `Nothing` then it's\nthe same as if no initial value were set.\n\n    example =\n        Form.text |> Form.withOptionalInitialValue .nickname\n\n    formOptions : { nickname : Maybe String } -> Form.Options String parsed { nickname : Maybe String } msg\n    formOptions currentProfile =\n        Form.options \"profile\"\n            |> Form.withInput currentProfile\n\n","type":"(input -> Maybe.Maybe initial) -> Form.Field.Field error value input initial kind constraints -> Form.Field.Field error value input initial kind constraints"},{"name":"withStep","comment":" Sets the `step` attribute on the form field for Field's with `Int` steps. See <https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/step>.\n\nFor `int` fields, the step will change the up/down buttons in the field's UI to increment/decrement by the given step.\n\n`Int` step values have different meanings for different kinds of Fields.\n\n  - [`date`](#date) - number of days\n  - [`time`](#time) - time in seconds\n\n","type":"Basics.Int -> Form.Field.Field error value input initial view { constraints | step : Basics.Int } -> Form.Field.Field error value input initial view constraints"}],"binops":[]},{"name":"Form.FieldView","comment":"\n\n@docs Input, Options, input, radio, Hidden, select, valueButton\n\n\n## Html.Styled Helpers\n\n@docs radioStyled, selectStyled, inputStyled, valueButtonStyled\n\n","unions":[],"aliases":[{"name":"Hidden","comment":" There are no render helpers for hidden fields because the `Form.renderHtml` helper functions automatically render hidden fields for you.\n","args":[],"type":"Internal.Input.Hidden"},{"name":"Input","comment":" The type for a Field that can be rendered using [`input`](#input) or [`inputStyled`](#inputStyled).\n","args":[],"type":"Internal.Input.Input"},{"name":"Options","comment":" The type for a Field that represents a set of options.\n\nCan be rendered as a dropdown:\n\n  - [`select`](#select)\n  - [`selectStyled`](#selectStyled)\n\nOr as a set of radio buttons:\n\n  - [`radio`](#radio)\n  - [`radioStyled`](#radioStyled)\n\n","args":["a"],"type":"Internal.Input.Options a"}],"values":[{"name":"input","comment":" Renders the [`Field`](Form-Field#Field) to [`Html`](https://package.elm-lang.org/packages/elm/html/latest/Html).\n\nThese Fields are defined using [`Form.Field`](Form-Field) using functions like [`Form.Field.text`](Form-Field#text),\n[`Form.Field.textarea`](Form-Field#textarea), [`Form.Field.int`](Form-Field#int), and [`Form.Field.date`](Form-Field#date).\n\nThis will render a form field HTML element with all of the appropriate attributes.\n\nOften it's convenient to create a helper function that adds labels and renders the field's error messages with any\nstyles and layout conventions in your application.\n\n    fieldView :\n        Form.Context String input\n        -> String\n        -> Validation.Field String parsed FieldView.Input\n        -> Html msg\n    fieldView context label field =\n        Html.div []\n            [ Html.label []\n                [ Html.text (label ++ \" \")\n                , FieldView.input [] field\n                , errorsView context field\n                ]\n            ]\n\n    errorsView :\n        Form.Context String input\n        -> Validation.Field String parsed kind\n        -> Html msg\n    errorsView { submitAttempted, errors } field =\n        if submitAttempted || Validation.statusAtLeast Validation.Blurred field then\n            errors\n                |> Form.errorsForField field\n                |> List.map (\\error -> Html.li [ Html.Attributes.style \"color\" \"red\" ] [ Html.text error ])\n                |> Html.ul []\n\n        else\n            Html.ul [] []\n\n","type":"List.List (Html.Attribute msg) -> Form.Validation.Field error parsed Form.FieldView.Input -> Html.Html msg"},{"name":"inputStyled","comment":" Same as [`input`](#input), but renders to [`Html.Styled`](https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/Html-Styled).\n","type":"List.List (Html.Styled.Attribute msg) -> Form.Validation.Field error parsed Form.FieldView.Input -> Html.Styled.Html msg"},{"name":"radio","comment":" Render an [`Options`](#Options) [`Field`](Form-Validation#Field) as a set of [`radio`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/radio) elements.\n\nRadio buttons are highly customizable. Even more so than dropdowns (`<select>` elements) because you can render HTML for each entry rather than just text.\n\nTo render using this `radio` function, you pass in\n\n  - list of HTML attributes to add to the top-level `<fieldset>` that is rendered around the radio inputs.\n  - A function that gives you the option render, and a function to render the radio element itself given a list of HTML attributes.\n  - The `Options` Field to render the radio buttons for\n\nExample:\n\n    import Form.FieldView as FieldView\n    import Html\n\n    type Size\n        = Small\n        | Medium\n        | Large\n\n    dropdownView field =\n        Html.div []\n            [ FieldView.radio []\n                (\\size toRadio ->\n                    Html.div []\n                        [ Html.label []\n                            [ Html.text (sizeToString size)\n                            , toRadio []\n                            ]\n                        ]\n                )\n                field\n            ]\n\n    sizeToString : Size -> String\n    sizeToString size =\n        case size of\n            Small ->\n                \"Small\"\n\n            Medium ->\n                \"Medium\"\n\n            Large ->\n                \"Large\"\n\n","type":"List.List (Html.Attribute msg) -> (option -> (List.List (Html.Attribute msg) -> Html.Html msg) -> Html.Html msg) -> Form.Validation.Field error parsed2 (Form.FieldView.Options option) -> Html.Html msg"},{"name":"radioStyled","comment":" Same as [`radio`](#radio), but renders to [`Html.Styled`](https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/Html-Styled).\n","type":"List.List (Html.Styled.Attribute msg) -> (parsed -> (List.List (Html.Styled.Attribute msg) -> Html.Styled.Html msg) -> Html.Styled.Html msg) -> Form.Validation.Field error parsed2 (Form.FieldView.Options parsed) -> Html.Styled.Html msg"},{"name":"select","comment":" Render an [`Options`](#Options) field as a [`select`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select) element.\n\n    import Form.FieldView as FieldView\n\n    type Size\n        = Small\n        | Medium\n        | Large\n\n    dropdownView field =\n        FieldView.select []\n            (\\size ->\n                ( -- we can optionally add HTML attributes here\n                  []\n                , sizeToString size\n                )\n            )\n            field\n\n    sizeToString : Size -> String\n    sizeToString size =\n        case size of\n            Small ->\n                \"Small\"\n\n            Medium ->\n                \"Medium\"\n\n            Large ->\n                \"Large\"\n\n","type":"List.List (Html.Attribute msg) -> (parsed -> ( List.List (Html.Attribute msg), String.String )) -> Form.Validation.Field error parsed2 (Form.FieldView.Options parsed) -> Html.Html msg"},{"name":"selectStyled","comment":" Same as [`select`](#select), but renders to [`Html.Styled`](https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/Html-Styled).\n","type":"List.List (Html.Styled.Attribute msg) -> (parsed -> ( List.List (Html.Styled.Attribute msg), String.String )) -> Form.Validation.Field error parsed2 (Form.FieldView.Options parsed) -> Html.Styled.Html msg"},{"name":"valueButton","comment":" Gives you a submit button that will submit the form with a specific value for the given Field.\n","type":"String.String -> List.List (Html.Attribute msg) -> List.List (Html.Html msg) -> Form.Validation.Field error parsed kind -> Html.Html msg"},{"name":"valueButtonStyled","comment":" Gives you a submit button that will submit the form with a specific value for the given Field.\n","type":"String.String -> List.List (Html.Styled.Attribute msg) -> List.List (Html.Styled.Html msg) -> Form.Validation.Field error parsed kind -> Html.Styled.Html msg"}],"binops":[]},{"name":"Form.Handler","comment":" This API allows you to try parsing one of several forms.\n\nThis is useful if you want to\n\n1.  Parse a form on the backend using code sharing to keep your backend and frontend validations in sync, and\n2.  Parse in-flight form submissions to derive pending or optimistic UI state\n\n`elm-pages` has some abstractions built around these ideas to help you receive form submissions on the backend, and\nautomatically manage in-flight form submissions. However, you can manually wire this in or build similar abstractions\nin your own framework or application.\n\nExample:\n\n    import Form\n    import Form.Field as Field\n    import Form.Handler exposing (Handler)\n    import Form.Validation as Validation\n\n    type Action =\n        UpdateProfile ( String, String )\n        | SendMessage ( String, String )\n\n\n    updateProfile : Form.HtmlForm String ( String, String ) input msg\n    updateProfile =\n        Form.form\n            (\\first last ->\n                { combine =\n                    Validation.succeed Tuple.pair\n                        |> Validation.andMap first\n                        |> Validation.andMap last\n                , view = \\_ -> []\n                }\n            )\n            |> Form.field \"first\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"last\" (Field.text |> Field.required \"Required\")\n            |> Form.hiddenKind ( \"kind\", \"update-profile\" ) \"Expected kind\"\n\n    sendMessage : Form.HtmlForm String ( String, String ) input msg\n    sendMessage =\n        Form.form\n            (\\to body ->\n                { combine =\n                    Validation.succeed Tuple.pair\n                        |> Validation.andMap to\n                        |> Validation.andMap body\n                , view = \\_ -> []\n                }\n            )\n            |> Form.field \"to\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"body\" (Field.text |> Field.required \"Required\" |> Field.textarea { rows = Nothing, cols = Nothing })\n            |> Form.hiddenKind ( \"kind\", \"send-message\" ) \"Expected kind\"\n\n    handler : Form.Handler.Handler String Action\n    handler =\n        Form.Handler.init UpdateProfile updateProfile\n        |> Form.Handler.with SendMessage sendMessage\n\n    Form.Handler.run\n        [ ( \"first\", \"Jane\" )\n        , ( \"last\", \"Doe\" )\n        , ( \"kind\", \"update-profile\" )\n        ]\n        handler\n\n    --> Form.Valid (UpdateProfile (\"Jane\", \"Doe\") )\n\n    Form.Handler.run\n        [ ( \"to\", \"Jane\" )\n        , ( \"body\", \"Hello!\" )\n        , ( \"kind\", \"send-message\" )\n        ]\n        handler\n\n    --> Form.Valid (SendMessage (\"Jane\", \"Hello!\") )\n\n@docs Handler\n\n@docs init, with\n\n@docs run\n\n","unions":[{"name":"Handler","comment":" A combined set of Form parsers which can be run with [`run`](#run)\n","args":["error","parsed"],"cases":[]}],"aliases":[],"values":[{"name":"init","comment":" Start building a `Handler`.\n","type":"(parsed -> combined) -> Internal.Form.Form error { combineAndView | combine : Form.Validation.Validation error parsed kind constraints } parsed input -> Form.Handler.Handler error combined"},{"name":"run","comment":" Parse your [`Handler`](#Handler) with the given raw form data into a [`Validated`](Form#Validated) value.\n","type":"List.List ( String.String, String.String ) -> Form.Handler.Handler error parsed -> Form.Validated error parsed"},{"name":"with","comment":" Include an additional `Form` as one of the possibilities to parse into.\n","type":"(parsed -> combined) -> Internal.Form.Form error { combineAndView | combine : Form.Validation.Validation error parsed kind constraints } parsed input -> Form.Handler.Handler error combined -> Form.Handler.Handler error combined"}],"binops":[]},{"name":"Form.Validation","comment":"\n\n\n## Validations\n\n@docs Field, Validation\n\n@docs succeed\n\n@docs andMap\n@docs andThen, fail, fromResult, map, map2, withError, withErrorIf, withFallback\n\n\n## Field Metadata\n\n@docs value, fieldName\n\n@docs FieldStatus, fieldStatus, fieldStatusToString\n\n@docs statusAtLeast\n\n\n## Mapping\n\n@docs map3, map4, map5, map6, map7, map8, map9\n\n\n## Global Validation\n\n@docs global\n\n","unions":[{"name":"FieldStatus","comment":" `elm-form` manages the state of a form's fields, including `FieldStatus`.\n\n`FieldStatus` goes through the following states in this order, and never goes backwards (unless it is changed manually through the [`Form.Model`](Form#Model) value):\n\n1.  `NotVisited` - The initial `FieldStatus` for all fields. The field hasn't been changed or focused.\n2.  `Focused` - The field has been focused, but not changed or blurred.\n3.  `Changed` - The field has had an input event, but has not yet been blurred (lost focus).\n4.  `Blurred` - The field has been blurred (lost focus).\n\nYou can use a [`Form`](Form#Form)'s `submitAttempted` state and/or a `Field`'s `FieldStatus` to decide when to render a `Field`'s validation errors.\n\nFor example, you might choose to render a `Field`'s validation errors once `Field` has been `Blurred` so that the user doesn't see validation errors before they've had a chance\nto input a valid value (it can be an annoying user experience to get error feedback too early).\n\nSee [`Form.errorsForField`](Form#errorsForField) for a common way to use a `Field`'s `FieldStatus`.\n\n","args":[],"cases":[["NotVisited",[]],["Focused",[]],["Changed",[]],["Blurred",[]]]}],"aliases":[{"name":"Field","comment":" Represents a form field. This value is used for two purposes:\n\n  - Render - Turn the `Field` into a view using [`Form.FieldView`](Form-FieldView)\n  - Parse - Use the `Field` to compose together with other `Field`s into a Validation which can be used to parse into the desired data type or add validation errors\n\nYou get a `Field` from the pipeline of fields defined using [`Form.field`](Form#field) and [`Form.hiddenField`](Form#hiddenField).\nThe only other way to get a `Field` is to use [`global`](#global). You can use this special `Field` to attach validation errors\nto the form as a whole rather than to a specific field.\n\nThis type is one of the key designs in this package. Because we can share this `Field` type between the view and the parsing,\nwe don't need to use \"stringly typed\" values to refer to fields in our form in an error-prone way. Instead, we know that a\n`Field` represents a form field that we have defined for the given [`Form`](Form#Form). It's a little confusing that this `Field`\ntype serves two purposes, but it allows us to have a safe way to reference a Form's fields, and doesn't require two\ndeclarations with a duplicate parameter list.\n\nSee the [`Form`](Form) docs for more on how to use `Field`s to render your `Form`'s view and define its `combine` `Validation`.\n\n","args":["error","parsed","kind"],"type":"Form.Validation.Validation error parsed kind { field : kind }"},{"name":"Validation","comment":" A `Validation` represents a parsed value or a list of errors.\n","args":["error","parsed","kind","constraints"],"type":"Pages.Internal.Form.Validation error parsed kind constraints"}],"values":[{"name":"andMap","comment":" Lets you combine Validation's in a pipeline.\n\n    import Form\n    import Form.Field as Field\n    import Form.Validation as Validation\n\n    example =\n        (\\first middle last ->\n            { combine =\n                Validation.succeed\n                    (\\vFirst vMiddle vLast ->\n                        vFirst ++ \" \" ++ vMiddle ++ \" \" ++ vLast\n                    )\n                    |> Validation.andMap first\n                    |> Validation.andMap middle\n                    |> Validation.andMap last\n            , view = \\_ -> []\n            }\n        )\n            |> Form.form\n            |> Form.field \"first\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"middle\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"last\" (Field.text |> Field.required \"Required\")\n\n","type":"Form.Validation.Validation error a named1 constraints1 -> Form.Validation.Validation error (a -> b) named2 constraints2 -> Form.Validation.Validation error b Basics.Never constraints3"},{"name":"andThen","comment":" Continue a `Validation` based on the given `parsed` value.\n\n    import Date\n    import Form\n    import Form.Field as Field\n    import Form.Validation as Validation\n\n    example : Form.HtmlForm String { date : Date, nights : Int } input msg\n    example =\n        (\\checkIn checkOut ->\n            { combine =\n                Validation.map2\n                    (\\checkinValue checkoutValue ->\n                        Validation.succeed\n                            { date = checkinValue\n                            , nights = Date.toRataDie checkoutValue - Date.toRataDie checkinValue\n                            }\n                            |> Validation.withErrorIf (Date.toRataDie checkinValue >= Date.toRataDie checkoutValue) checkIn \"Must be before checkout\"\n                    )\n                    checkIn\n                    checkOut\n                    |> Validation.andThen identity\n            , view = \\_ -> []\n            }\n        )\n            |> Form.form\n            |> Form.field \"checkin\"\n                (Field.date\n                    { invalid = \\_ -> \"Invalid\" }\n                    |> Field.required \"Required\"\n                )\n            |> Form.field \"checkout\"\n                (Field.date\n                    { invalid = \\_ -> \"Invalid\" }\n                    |> Field.required \"Required\"\n                )\n\n","type":"(parsed -> Form.Validation.Validation error mapped named1 constraints1) -> Form.Validation.Validation error parsed named2 constraints2 -> Form.Validation.Validation error mapped Basics.Never constraintsAny"},{"name":"fail","comment":" Add an error to the given `Field`, short-circuiting its parsed value so that it will fail to parse.\nThis can be helpful if you want to fail with a value that you can combine together with other values because\nit has an unbound `parsed` type variable. Similar to how [`Json.Decode.fail`](https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#fail)\ngives you a `Decoder a`.\n\nSee [`withError`](#withError) if you want to add an error without short-circuiting the parsed value.\n\n","type":"error -> Form.Validation.Field error parsed1 field -> Form.Validation.Validation error parsed kind constraints"},{"name":"fieldName","comment":" Get the `Field`'s name.\n","type":"Form.Validation.Field error parsed kind -> String.String"},{"name":"fieldStatus","comment":" Get the `Field`'s [`FieldStatus`](#FieldStatus).\n","type":"Form.Validation.Field error parsed kind -> Form.Validation.FieldStatus"},{"name":"fieldStatusToString","comment":" Mostly useful for debugging, you'll usually want to compare `FieldStatus` to other `FieldStatus` values or use helpers like [`statusAtLeast`](#statusAtLeast).\n","type":"Form.Validation.FieldStatus -> String.String"},{"name":"fromResult","comment":" Resolve a `Result` within a `Field`. If it is `Err`, the error will be added to the `Field`'s errors.\n","type":"Form.Validation.Field error (Result.Result error parsed) kind -> Form.Validation.Validation error parsed Basics.Never Basics.Never"},{"name":"global","comment":" A `Field` that represents the form as a whole. This is useful for attaching validation errors to the form as a whole rather than to a specific field.\n","type":"Form.Validation.Field error () Basics.Never"},{"name":"map","comment":" Apply a function to the parsed value.\n\n    import Form.Validation as Validation\n\n    type Uuid\n        = Uuid String\n\n    example =\n        (\\uuid ->\n            { combine =\n                Validation.succeed identity\n                    |> Validation.andMap (uuid |> Validation.map Uuid)\n            , view = \\_ -> []\n            }\n        )\n            |> Form.form\n            |> Form.hiddenField \"uuid\" (Field.text |> Field.required \"Required\")\n\n","type":"(parsed -> mapped) -> Form.Validation.Validation error parsed named constraint -> Form.Validation.Validation error mapped erasedKind erasedConstraints"},{"name":"map2","comment":" Combine together two `Validation`'s.\n\n    import Form\n    import Form.Field as Field\n    import Form.Validation as Validation\n\n    example =\n        (\\first last ->\n            { combine =\n                Validation.map2 Tuple.pair\n                    first\n                    last\n            , view = \\_ -> [{- ... -}]\n            }\n        )\n            |> Form.form\n            |> Form.field \"first\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"last\" (Field.text |> Field.required \"Required\")\n\n","type":"(a -> b -> c) -> Form.Validation.Validation error a named1 constraints1 -> Form.Validation.Validation error b named2 constraints2 -> Form.Validation.Validation error c Basics.Never constraintsAny"},{"name":"map3","comment":" ","type":"(a1 -> a2 -> a3 -> a4) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 Basics.Never constraintsAny"},{"name":"map4","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 Basics.Never constraintsAny"},{"name":"map5","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 Basics.Never constraintsAny"},{"name":"map6","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 named6 constraints6 -> Form.Validation.Validation error a7 Basics.Never constraintsAny"},{"name":"map7","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 named6 constraints6 -> Form.Validation.Validation error a7 named7 constraints7 -> Form.Validation.Validation error a8 Basics.Never constraintsAny"},{"name":"map8","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 named6 constraints6 -> Form.Validation.Validation error a7 named7 constraints7 -> Form.Validation.Validation error a8 named8 constraints8 -> Form.Validation.Validation error a9 Basics.Never constraintsAny"},{"name":"map9","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 named6 constraints6 -> Form.Validation.Validation error a7 named7 constraints7 -> Form.Validation.Validation error a8 named8 constraints8 -> Form.Validation.Validation error a9 named9 constraints9 -> Form.Validation.Validation error a10 Basics.Never constraintsAny"},{"name":"statusAtLeast","comment":" `elm-form` manages form fields' `FieldStatus` in the order described in [`FieldStatus`](#FieldStatus).\n\nThis function is useful when writing a condition for when to show a `Field`'s validation errors in the view.\nSee [`Form.errorsForField`](Form#errorsForField) for an example.\n\n","type":"Form.Validation.FieldStatus -> Form.Validation.Field error parsed kind -> Basics.Bool"},{"name":"succeed","comment":" Get a `Combined` value that successfully parses into the given value with no errors.\n\nHelpful for starting a chain of `Validation` functions that will eventually parse into a value. See [`andMap`](#andMap)\nfor an example of a common idiom.\n\n","type":"parsed -> Form.Validation.Validation error parsed kind constraints"},{"name":"value","comment":" Get the parsed value if it is parseable (could be either invalid or valid).\n","type":"Form.Validation.Validation error parsed named constraint -> Maybe.Maybe parsed"},{"name":"withError","comment":" Add an error to the given `Field`.\n","type":"Form.Validation.Field error parsed1 field -> error -> Form.Validation.Validation error parsed2 named constraints -> Form.Validation.Validation error parsed2 named constraints"},{"name":"withErrorIf","comment":" Conditionally add an error to the given `Field`.\n\n    import Date\n    import Form.Validation as Validation\n\n    example checkIn checkOut =\n        Validation.map2\n            (\\checkinValue checkoutValue ->\n                Validation.succeed\n                    { date = checkinValue\n                    , nights = Date.toRataDie checkoutValue - Date.toRataDie checkinValue\n                    }\n                    |> Validation.withErrorIf (Date.toRataDie checkinValue >= Date.toRataDie checkoutValue) checkIn \"Must be before checkout\"\n            )\n            checkIn\n            checkOut\n            |> Validation.andThen identity\n\n","type":"Basics.Bool -> Form.Validation.Field error ignored field -> error -> Form.Validation.Validation error parsed named constraints -> Form.Validation.Validation error parsed named constraints"},{"name":"withFallback","comment":" Include a fallback value to parse into. Does not remove any previous validation errors that have been encountered\nso it will not effect whether it parses to `Valid` or `Invalid`.\n","type":"parsed -> Form.Validation.Validation error parsed named constraints -> Form.Validation.Validation error parsed named constraints"}],"binops":[]}]